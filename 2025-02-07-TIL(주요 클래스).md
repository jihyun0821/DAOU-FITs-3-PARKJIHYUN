# Object

- 모든 클래스의 최상위 부모
- equals, hashCode, toString 등 기본 메서드 가짐
- equals 재정의 시, instanceof로 타입 확인 후 캐스팅해서 내용 비교함

```java
package lecture.day3;

public class MyObjectClass {
    String name;

    @Override
    public boolean equals(Object obj) {
        boolean result = false;
        // type이 같은지 확인, obj가 MyObjectClass 타입이면 캐스팅 후 name 비교
        if(obj instanceof MyObjectClass) {
            MyObjectClass target = (MyObjectClass) obj;
            if(this.name.equals(target.name)) result = true;
        }
        return result;
    }

    public static void main(String[] args) {
        MyObjectClass obj1 = new MyObjectClass();
        MyObjectClass obj2 = new MyObjectClass();

        String objName = "Hello";
        obj1.name = "Hello";
        obj2.name = "Hello";

        System.out.println(obj1 == obj2); // false, 서로 다른 참조임
        System.out.println(objName == obj1.name); // true, 리터럴이기 때문에 동일 String Pool 객체 참조
        System.out.println(obj1.equals(obj2)); // equals 재정의 덕분에 true 나옴
    }
}

```

# String

string은 immutable

`String name = “journnie”;`

- 리터럴 : 어떤 개념을 코드로 사용하기 위한 표기법
- heap String Pool영역에 생성

`String str3 = new String("Hello");`

- heap에 별도 문자열 객체 생성

```java
package lecture.day4;

public class StringTest {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "Hello";
        String str3 = new String("Hello");

        System.out.println(str1 == str2);  // true, 같은 리터럴이면 같은 객체임
        System.out.println(str1 == str3);  // false, new String()은 새로운 힙 객체임
        System.out.println(str1.equals(str3));  // true, 내용이 같음
    }
}

```

- `equals()` : 내용 비교
- `==` : 참조 비교

# Array

- 크기 고정 자료구조
    - 선언할 때 크기 지정해줘야 함
- 기본 자료형이나 객체 저장 가능

```java
String[] stringArray = new String[5];

```

# ArrayList

- 배열과 유사
- 크기가 유동적
- 다른 Data type 저장 가능
    - 근데 이럴일이 많이 없긴 함
    - 거의 다 같은  data type
        
        ⇒ Generic
        
- 객체만 저장할 수 있음
    - primitive type 저장 불가.
    - instance. reference type var만 저장 가능
- **하지만 일반적으로 제네릭 이용**
    - 같은 데이터 타입만 저장하는게 국룰

```java
package lecture.day4;
//import java.util.ArrayList;

import java.util.ArrayList;
import java.util.List;

public class ArrayListTest {

    public static void main(String[] args) {
        // Array
        String[] stringArray = new String[5];

        // Array List
        // 클래스 불러올때는 패키지명 전체 써야함
        java.util.ArrayList list = new java.util.ArrayList();
        // 객체이기 때문에 당연히 method를 통해 객체 제어
        list.add("와와와"); // String 객체를 첫번째 칸에 저장
        // primitive type은 list안에 들어갈 수 없음
        list.add(100); // int는 원래 안 되지만 오토박싱으로 Integer 객체 저장됨
        // Java에서는 wrapper type 제공
        int k = 10000;
        Integer kk = new Integer(k); // 이런 식으로 사용할 수 잇음
        // 하지만 오토박스 만들어져서 list에 저장됨

        list.add(true); // 리스트를 통해서

        // 어떤 타입이 나올지 모르기 때문에 Obj 사용
        for(Object o : list){
            System.out.println(o);
        }
//
//        ArrayList<String> sent = new ArrayList<String>();
        List<String> sent = new ArrayList<String>(); // 상위 타입 중 인터페이스 쓰는 게 국룰 - 프로그래밍 유연성 높아짐

    }
}

```

# Map

Hash Map

- 집합형 자료구조
- key, value 쌍으로 저장
    - primitive type 사용 불가
        - 어차피 써도 wrapper class 어쩌구
    - key, value  둘 다 개겣=
- key → data에 access
    - 그래서 기본적으로 iterable 아닌데
    - 편의성을 위해 순서개념 도입한 맵 있음

```java
package lecture.day4;

import java.util.HashMap;
import java.util.Map;

public class HashMapTest {
    public static void main(String[] args) {
        HashMap hashMap = new HashMap();
        // 상위 인터페이스로 쓰기
        Map<Integer, String> map = new HashMap<>();

        map.put(1, "aaa");
        map.put(2, "bbb");

        // 데이터 가져올 때는 get()
        System.out.println(map.get(1));
    }

}

```

# Set

> *interface Set*
> 
> 
> class HashSet
> 
- 중복 없음
- 순서 없음
    - Iterator
        
        `Iterator<String> iterator = strSet.iterator();`
        

```java
package lecture.day4;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetTest {
    public static void main(String[] args) {
        Set<String> strSet = new HashSet<>();

        strSet.add("aaa");
        strSet.add("bbb");
        strSet.add("ccc");
        strSet.add("aaa"); // 중복 저장 안 됨

        System.out.println(strSet);

        // for-each로 순회
        for(String s : strSet) {
            System.out.println(s);
        }

        // forEach, 메서드 레퍼런스 또는 람다 사용
        strSet.forEach(System.out::println);
        strSet.forEach(i -> System.out.println(i));

        // Iterator 사용
        Iterator<String> iterator = strSet.iterator();
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}

```

# Exception

특정상황이 발생하면 JVM이 이 클래스의 instance를 생성

프로그램이 비정상적으로 종료되는 것을 방지

→ Exception Handling

try / catch / finally

```java
package lecture.day4;

public class ExceptionTest {
    public static void main(String[] args) {
        System.out.println("Exception occurred");

        // 이 상황에 맞는 Exception class를 이용해 JVM이 객체 생성
        // 이 생성된 객체를 우리가 처리하지 않으면 프로그램이 비정상 종료
        Object obj = null;
        try {
            int result = 10/0; // NullPointerException
            System.out.println(obj.toString());
        } catch (NullPointerException e) {
            // 예외 상황 처리 코드
            System.out.println(e.getMessage());
            // 강제 종료 되지 않음
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        } catch (Exception e) {
            // 상위 클래스일수록 뒤에
        } finally {
            System.out.println("finally block");
        }

        System.out.println("Program ");
    }
}

```
