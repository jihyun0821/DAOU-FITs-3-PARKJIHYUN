# Java Database Connectivity

> Java를 이용하여 DB를 활용하는 API
> 

```java
import java.sql.*;

public class FirstConnection {
    public static void main(String[] args) {
        try {
            // 1.
            // 무조건 예외처리 해줘야함
            // ojdbc11.jar\jdbc\driver\Oracle
            Class.forName("oracle.jdbc.driver.OracleDriver"); // ClassNotFoundException
            System.out.println("Driver loaded");

            // 2.
            String url = "jdbc:oracle:thin:@localhost:1521:xe"; // xe: SID -> 데이터베이스에 접근
            String username = "C##JDBC_PRACTICE";
            String password = "1234";
            Connection con = DriverManager.getConnection(url, username, password); // SQLException
            System.out.println("Connected to database : " + con.getMetaData().getDatabaseProductName());

            // 3.
            String sql = "SELECT * FROM BOOK";
            PreparedStatement psmt = con.prepareStatement(sql);

            // 4.
            ResultSet rs = psmt.executeQuery(sql);
            System.out.println("Results : " + rs);
            System.out.println(rs.next());

            // 5.
//            System.out.println(rs.getString(0));
//            while (rs.next()) {
//                System.out.println(rs.getString(2));
//            }

            // 6.
            rs.close();
            psmt.close();
            con.close();
            System.out.println("Resources Closed");

        } catch (ClassNotFoundException e) {
            System.out.println("Driver not found");
            throw new RuntimeException(e);
        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            throw new RuntimeException(e);
        }

    }

}

```

## 1. JDBC Driver Loading

`Class.forName("oracle.jdbc.driver.OracleDriver");`

- DB 연결 전에 JDBC 드라이버 로드
- 드라이버 없으면 ClassNotFoundException 발생함
    - try~catch 해야함

## 2. Connect Database

`Connection con = DriverManager.getConnection(url, username, password); // SQLException`

연결이 성공하면 java.sql.Connection 객체 생성됨

연결하려면 3가지 정보 필요

- Database URL
- ID / PW

**접속 방식**

- thin
    
    느리지만 범용적
    
- oci
    
    드라이버를 통해서
    
    - 라이브러리로 접속해서 hardware dependent 하지만 빠름

## 3. SQL Statement

- Statement
- PreparedStatement
    
    미리 만들어놓은 sql구문을 가지고 만듦
    
    - 코드 작성하기 좋음
    - 효율이 좋음 - 빠름
    - 보안 - sql injection 방지
        - in parameter 사용 가능
    
    ⇒ 얘를 많이 씀
    
- CallableStatement
    
    내장함수 어쩌구
    
    Stored Procedure 호출하기 위해서
    

### SQL 작성 방법

- **문자열 연결 방식**
    - 검색어(search_title)를 문자열과 직접 연결해서 SQL문 완성
    
    ```java
    String sql = "select * from book where title like '%" + search_title + "%'";
    ```
    
    - SQL Injection 위험 있음
    - search_title에 따옴표 등 특수문자가 있으면 오류 발생 가능
- **문자열 포매팅 방식 (formatted 메서드 사용)**
    - 포맷 지정자로 search_title 삽입
    
    ```java
    String sql = "select * from book where BTITLE like '%%%s%%'".formatted(search_title);
    
    ```
    
    - 문자열 연결보다 조금 깔끔하지만 여전히 SQL Injection 위험 있음
    - 검색어를 직접 문자열에 삽입하는 점은 동일함
- **PreparedStatement 방식 (플레이스홀더 사용)**
    
    `?` 플레이스홀더 사용해서 파라미터 바인딩
    
    PreparedStatement 객체에서 `setString()`등으로 값 대입
    
    ```java
    String sql = "select * from book where BTITLE like ?";
    ```
    
    - SQL Injection 방지
    - 쿼리 미리 컴파일되어 성능 개선 가능
    - 가독성 높음

## 4. Execute Query

- `executeUpdate()` - INSERT, UPDATE, DELETE
- `executeQuery()` - SELECT

## 5. Get Results

- `int result = executeUpdate()` - (int) SQL에 의해 영향을 받은 행 수
- `ResultSet rs = executeQuery()`
    
    ResultSet은 커서처럼 작동함 - 맨 처음 pointer - column을 가리키는
    
    - `rs.next()` == boolean
    - `rs.getString(*col*)` - col은 열 번호 또는 열 타이틀

## 6. Close Resources

관련 자원은 GC 관여 안 함 → 사용 후 반드시 close() 호출해야 함

만든 순서 역순으로 닫아줘야함

- ResultSet
- PreparedStatment
- Connection

# JDBC에 Transaction 설정하기

## Transaction

- **Atomicity**: All or Nothing
- **Consistency**: Enforcing Data Integrity and Rules
- **Isolation**: Taming Concurrency
- **Durability**: Surviving the Storm

## JDBC에 Transaction 설정하기

별도 Transaction 설정 안했다면

→ sql 한 줄이 1 Transaction

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionTest {
    public static void main(String[] args) {
        Connection con;
        PreparedStatement pstmt;

        try {
            // 1. 드라이버 로드
            Class.forName("oracle.jdbc.driver.OracleDriver");

            // 2. Connection
            String url = "jdbc:oracle:thin:@localhost:1521:xe";
            String username = "C##JDBC_PRACTICE";
            String password = "1234";
            con = DriverManager.getConnection(url, username, password); // autoCommit mode로 Connection 생성
            // Transaction 설정 시작
            con.setAutoCommit(false); // DB에 영향 안미침4
                // 명시적으로 con.commit() || con.rollback() 호출되면
                // transaction 종료
                // 만약 추가적으로 구문이 나오지 않고 connection이 정상종료되면 con.commit()으로 간주

            // 3. SQL 구문 작성
            String sql = "insert into MEMBERS values(?,?)";
            pstmt = con.prepareStatement(sql);
            pstmt.setString(1, "3");
            pstmt.setString(2, "kellyy");

            // 4. SQL 구문 실행
            int result = pstmt.executeUpdate();

            // 5. 결과 처리
            System.out.println(result);

//            con.rollback(); // transaction 무효화
            con.commit(); // commit!

            // 6. 리소스 해제
            pstmt.close();
            con.close();

        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

    }
}

```
