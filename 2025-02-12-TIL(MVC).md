# Layered Architecture

프로그램은 아래와 같은 구성요소를 지켜 프로그래밍 하는 것이 좋음 ⇒ **Programming Pattern**

### Presentation Layer

입출력 처리

사용자에게 값을 입력받고 결과 출력

### Business(Logic) Layer

로직 처리

### Persistence Layer

DB에 접근하여 데이터 핸들링

### Database Layer

oracle, mySQL

# MVC

## Model

- Data Model (VO)
- Service Model - 로직처리 전담 객체(class)
    - 순수 로직 처리 - transaction 담당
    - DB 처리 직접 안함 → DAO (Data Access Object)

## View

입출력 담당 (Presentation Layer) 

(javaFX) Stage, FXML

## Controller

View ← Controller → Model

view에서 입력받아 어떤 로직을 model에 전달해줄지

event 처리

프로그램 처리는 service model에서

## DAO (Data Access Object)

DB 처리

business logic (transaction) 안함

only DB access - CRUD 단발성 쿼리 실행

```java
package lecture.day6.booksearch;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.cell.TextFieldTableCell;
import javafx.util.converter.IntegerStringConverter;
import lecture.day6.booksearch.vo.Book;

import java.net.URL;
import java.sql.*;
import java.util.Arrays;
import java.util.List;
import java.util.ResourceBundle;

public class JavaFXTableViewController implements Initializable {
    @FXML
    private TableView<Book> tableView;
    @FXML
    private Button searchBtn;
    @FXML
    private TextField searchField;

    @FXML
    private TableColumn<Book, String> isbnCol;
    @FXML
    private TableColumn<Book, String> titleCol;
    @FXML
    private TableColumn<Book, Integer> priceCol;
    @FXML
    private TableColumn<Book, String> authorCol;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        // TableView를 편집 가능하도록 설정
        tableView.setEditable(true);

        // === ISBN 컬럼 설정 (문자열) ===
        isbnCol.setCellValueFactory(new PropertyValueFactory<>("bisbn"));
        isbnCol.setCellFactory(TextFieldTableCell.forTableColumn());
        isbnCol.setOnEditCommit(event -> {
            Book book = event.getTableView().getItems().get(event.getTablePosition().getRow());
            String oldISBN = event.getOldValue(); // 수정 전의 ISBN
            String newISBN = event.getNewValue();
            book.setBisbn(newISBN);
            // DB 업데이트 시, WHERE 조건에 수정 전 ISBN을 사용
            updateBookField("BISBN", newISBN, oldISBN);
        });

        // === 제목 컬럼 설정 (문자열) ===
        titleCol.setCellValueFactory(new PropertyValueFactory<>("btitle"));
        titleCol.setCellFactory(TextFieldTableCell.forTableColumn());
        titleCol.setOnEditCommit(event -> {
            Book book = event.getTableView().getItems().get(event.getTablePosition().getRow());
            String newTitle = event.getNewValue();
            book.setBtitle(newTitle);

            // ISBN이 현재 키 역할을 하므로, 현재 book.getBisbn()을 사용
            updateBookField("BTITLE", newTitle, book.getBisbn());
        });

        // === 가격 컬럼 설정 (정수) ===
        priceCol.setCellValueFactory(new PropertyValueFactory<>("bprice"));
        // 정수 값을 편집하기 위해 IntegerStringConverter 사용
        priceCol.setCellFactory(TextFieldTableCell.forTableColumn(new IntegerStringConverter()));
        priceCol.setOnEditCommit(event -> {
            Book book = event.getTableView().getItems().get(event.getTablePosition().getRow());
            Integer newPrice = event.getNewValue();
            book.setBprice(newPrice);
            updateBookField("BPRICE", newPrice, book.getBisbn());
        });

        // === 저자 컬럼 설정 (문자열) ===
        authorCol.setCellValueFactory(new PropertyValueFactory<>("bauthor"));
        authorCol.setCellFactory(TextFieldTableCell.forTableColumn());
        authorCol.setOnEditCommit(event -> {
            Book book = event.getTableView().getItems().get(event.getTablePosition().getRow());
            String newAuthor = event.getNewValue();
            book.setBauthor(newAuthor);
            updateBookField("BAUTHOR", newAuthor, book.getBisbn());
        });

        // 검색 버튼 클릭 시 TableView에 데이터 채우기
        searchBtn.setOnAction(event -> {
            ObservableList<Book> books = FXCollections.observableArrayList();
            String searchText = searchField.getText();
            System.out.println("검색어: " + searchText);

            try {
                // Oracle JDBC 드라이버 로드
                Class.forName("oracle.jdbc.driver.OracleDriver");
                String db_url = "jdbc:oracle:thin:@localhost:1521:xe";
                String username = "C##JDBC_PRACTICE";
                String password = "1234";
                Connection con = DriverManager.getConnection(db_url, username, password);

                String sql = "SELECT * FROM BOOK WHERE BTITLE LIKE ?";
                PreparedStatement ps = con.prepareStatement(sql);
                ps.setString(1, "%" + searchText + "%");
                ResultSet rs = ps.executeQuery();

                while (rs.next()) {
                    // Book 생성 시, 기본키(ID)도 포함되어 있어야 합니다.
                    books.add(new Book(
                            rs.getString("BISBN"),
                            rs.getString("BTITLE"),
                            rs.getInt("BPRICE"),
                            rs.getString("BAUTHOR")
                    ));
                }
                tableView.setItems(books);

                // 자원 해제
                rs.close();
                ps.close();
                con.close();
            } catch (ClassNotFoundException | SQLException e) {
                e.printStackTrace();
            }
        });
    }

    private void updateBookField(String columnName, Object newValue, Object keyValue) {
        // 허용된 컬럼명 목록 (대소문자 주의: DB 컬럼명에 맞게 지정)
        List<String> allowedColumns = Arrays.asList("BISBN", "BTITLE", "BPRICE", "BAUTHOR");
        if (!allowedColumns.contains(columnName)) {
            throw new IllegalArgumentException("허용되지 않은 컬럼명: " + columnName);
        }

        // 예시 SQL: 키로 ISBN을 사용
        String sql = "UPDATE BOOK SET " + columnName + " = ? WHERE BISBN = ?";

        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            String db_url = "jdbc:oracle:thin:@localhost:1521:xe";
            String username = "C##JDBC_PRACTICE";
            String password = "1234";
            try (Connection con = DriverManager.getConnection(db_url, username, password);
                 PreparedStatement ps = con.prepareStatement(sql)) {

                // newValue의 타입에 따라 PreparedStatement의 setter 선택
                if (newValue instanceof String) {
                    ps.setString(1, (String) newValue);
                } else if (newValue instanceof Integer) {
                    ps.setInt(1, (Integer) newValue);
                } else {
                    ps.setObject(1, newValue);
                }

                // keyValue는 기본적으로 문자열(ISBN)이라고 가정
                ps.setString(2, keyValue.toString());

                int affectedRows = ps.executeUpdate();
                if (affectedRows == 0) {
                    System.err.println("DB 업데이트 실패: " + columnName + " 컬럼이 업데이트되지 않음.");
                }
            }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }
    }

}

```

View → Controller → Service → DAO

- View
    - 화면 그리기
    - 입력 받기 - 버튼, 텍스트 필드
- Controller
- Service
- DAO

# Dependency Injection

## Step 1: 기본 DAO 구현

> `Main.java`
> 
> - UserDAO를 직접 new 해서 사용
> 
> `UserDAO.java` 
> 
> - CRUD 메서드마다 DB 연결 로직이 하드코딩 되어 있음
>     - 중복 코드 많음
> 
> `User.java`
> 
- 결합도가 높아 유지보수가 힘들어짐

---

## Step 2: 메서드 추출로 중복 코드 제거

> `Main.java`
> 
> - UserDAO를 직접 new 해서 사용
> 
> `UserDAO.java` 
> 
> - DB 연결 관련 중복 코드를 별도의 메서드로 추출함
> 
> `User.java`
> 
- 재사용 측면에서는 약간 개선되었지만, 결합도는 크게 낮아지지 않음
- 여전히 UserDAO 안에 DB 연결 구현이 하드코딩되어 있음

---

## Step 3: Template Method Pattern 적용

> `Main.java`
> 
> - KUserDAO를 new 해서 사용
> 
> `UserDAO.java`  (abstract class)
> 
> - DB 연결 관련 추상 메서드 + CRUD
> 
> [`KUserDAO.java`](http://KUserDAO.java) extends UserDAO
> 
> - KUserDAO 같은 하위 클래스에서 구체적인 구현(예, SQL 구문, 연결 방법 등)을 오버라이딩하도록 함
> 
> `User.java`
> 
- UserDAO를 추상 클래스 또는 상위 클래스로 만들고, DB 연결 등 기본 로직의 흐름을 구현함
- 상위 클래스에서 기본 로직 제공, 하위 클래스는 필요한 부분만 변경함
- 기본 로직의 흐름은 재사용할 수 있으나, 상속을 전제로 하므로 단일 상속 제약 있음

---

## Step 4: 상속 배제하고 재활용 방법 (SimpleConnectionMaker 방식)

> `Main.java`
> 
> - 
> 
> `*SimpleConnectionMaker*.java`
> 
> - DB 연결 객체를 생성하는 역할을 별도 클래스에서 담당함
> 
> `UserDAO.java`
> 
> - 기존 DB 연결 로직을 제거하고, 별도 클래스에서 연결 객체를 생성하도록 함
>     - UserDAO 내부에서 DB 연결을 위한 특정 클래스 이름에 의존함 (예, SimpleConnectionMaker new 로 생성)
> 
> `User.java`
> 
- DB 연결과 관련된 변경 사항을 별도 클래스(SimpleConnectionMaker 등)로 분리함
    - 재사용이 가능해짐
- UserDAO 내부에 특정 클래스 이름(SimpleConnectionMaker)이 하드코딩되어 있음
    - 해당 클래스에 강하게 결합(tightly coupled)되어 있음

---

## Step 5: 인터페이스 도입

> `Main.java`
> 
> - UserDAO와 ConnectionMaker 인터페이스만 알면 됨
> - 구체적인 구현체는 인터페이스를 통해 캡슐화됨
> 
> `*ConnectionMaker*.java` (interface)
> 
> - DB 연결 객체 생성에 관한 표준 계약(메서드 시그니처)을 정의함
> 
> `KConnectionMaker.java` implements ConnectionMaker
> 
> - ConnectionMaker 인터페이스를 구현해서 실제 DB 연결 로직 제공함
> 
> `UserDAO.java`
> 
> - DB 연결 객체 생성을 위해 특정 클래스에 의존하지 않고, ConnectionMaker 인터페이스 타입으로 선언함
>     - UserDAO 내부에서 new KConnectionMaker()로 직접 객체 생성
> 
> `User.java`
> 
- 상속 대신 인터페이스(ConnectionMaker)를 도입함
- KConnectionMaker가 ConnectionMaker 인터페이스를 구현하게 함
    - **UserDAO는 오직 인터페이스에만 의존**하게 되어 결합도가 낮아짐
- UserDAO 내부에서 구체적인 클래스 이름 대신 ConnectionMaker 타입으로 선언함
    - 예:
        
        ```java
        UserDAO() {
             connectionMaker = new KConnectionMaker();
        }
        
        ```
        
- 이제 사용자는 자신이 원하는 이름과 기능을 가진 ConnectionMaker 구현체를 만들 수 있음
- 여전히 UserDAO 내부에서 new KConnectionMaker()로 직접 객체 생성하므로 완전한 decoupling은 아님

---

## Step 6: Constructor Injection을 통한 완전한 DI 적용

> `Main.java`
> 
> - UserDAO 객체 생성 시, **생성자를 통해 외부에서 원하는 ConnectionMaker 구현체를 주입**함
> 
> `*ConnectionMaker*.java` (interface)
> 
> - DB 연결 객체 생성에 관한 표준 계약(메서드 시그니처)을 정의함
> 
> `KConnectionMaker.java` implements ConnectionMaker
> 
> - ConnectionMaker 인터페이스를 구현해서 실제 DB 연결 로직 제공함
> 
> `UserDAO.java`
> 
> - **더 이상 내부에서 new 키워드로 ConnectionMaker 객체를 생성하지 않음**
>     - 생성자에서 ConnectionMaker 객체를 매개변수로 받아서, DI 컨테이너나 클라이언트가 원하는 구현체를 주입받음
> 
> `User.java`
> 
- UserDAO 생성자에서 ConnectionMaker 객체를 외부에서 주입받음
    - 예:
        
        ```java
        UserDAO(ConnectionMaker connectionMaker) {
             // 직접 객체 생성하지 않고, 외부에서 주입받음
             this.connectionMaker = connectionMaker;
        }
        
        ```
        
- Main이나 다른 클라이언트가 원하는 ConnectionMaker 구현체(KConnectionMaker, DConnectionMaker 등)를 전달할 수 있음
- UserDAO는 이제 특정 구현 클래스에 의존하지 않게 됨
- 사용자가 직접 주입할 구현체를 선택할 수 있어 자유도가 극대화됨
- 결합도가 크게 낮아져 재사용성과 유연성이 극대화됨
